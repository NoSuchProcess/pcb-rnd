<HTML>
<BODY>
<H1> The actions package </H1>

The action package is used to register actions and menus in PCB and
to execute existing actions. In PCB actions
are generated when the user selects a menu, presses a key or issues a
command on the PCB command line.

<H2> Registration of new actions </H2>
The script may register new actions
using arbitrary action names. If any of the registered actions is
detected, an ACTE_action event is sent to the script. If multiple
actions are used in a script, argument <I>name</I> of the event handler
can be used to identify the triggering action. <small>(This may be time consuming
in scripting languages (a series of string comparison) - those scripts
binding to frequent actions should not bind to too many different actions.)</small>
pcb-gpmi guarantees that the event handler of a script is triggered only
when an action is caught that previously was registered by the same script.
<P>
The process of binding an action:
<OL>
	<LI> create an event handler for event <I>ACTE_action</I>
	<LI> register one or more actions using function <I>action_register</I>
	<LI> optional: when the event handler is triggered, check argument <I>name</I> (for scripts with multiple actions registered)
	<LI> optional: use argument <I>argc</I> and function <I>action_arg</I> to fetch action arguments
	<LI> optional: use arguments <I>x, y</I> to learn the cursor position on the layout.
</OL>

Example (written in lua):
<PRE>
-- load the package
PkgLoad("pcb-gpmi/actions", 0);

-- action callback
function ev_action(id, name, argc, x, y)
	if name == "cake" then
		size = action_arg(1);
		-- put cake drawing code here
	else
		-- must be candy
		amount = action_arg(1);
		-- put candy drawing code here
	end
end

-- register and bind action
action_register("cake",  "cake center xy?", "cake service", "cake(size)", "");
action_register("candy", "candy cloud center xy?", "cake service", "candy(amount)", "");
Bind("ACTE_action", "ev_action");
</PRE>
<p>
When the script is unloaded all actions the script registered 
are removed from pcb-rnd automatically.

<H2> Executing actions </H2>
An existing action can be executed using the action() call. The only one
argument is a command line string. The syntyax is the same as in pcb
command line.

Example (written in lua):
<PRE>
PkgLoad("pcb-rnd-gpmi/actions", 0);

function ev_action1(id, name, argc, x, y)
	action("undo()")
	action("undo()")
end

-- register and bind action
action_register("untwo", "", "undo twice", "untwo()", "CONTEXT!");
</PRE>
<p>
The above script registers a new action called untwo(). When untwo() is executed,
it exectues action undo() twice.


<H2> Creating menus </H2>
It is possible to insert menus and submenus runtime, using the call
create_menu(). The script should do this only after the gui has been initialized.
The most common way is to create all menus from the ACTE_gui_init event,
which is called after the gui finished setting up.
<p>
The first argument of create_menu() is the menu path. The path is a list
of visible menu names separated by slashes (e.g. "File/Save as..." means
"File" menu, "Save as..." submenu). By <b>convention</b>, scripts should
create new menu items under the "Plugins/" menu.
<p>
The following example lua script registers a new menu item
<pre>
PkgLoad("pcb-rnd-gpmi/actions", 0);

function ev_gui_init(argc, argv)
	create_menu("Plugins/foo", "undo()", "o", "Ctrl&lt;Key&gt;o", "tooltip for foo");
end

-- register and bind action
Bind("ACTE_gui_init", "ev_gui_init");
</pre>
<p>
When the user clicks on the menu, the action script specified in the second argument
of create_menu() is executed. Thus the script usually registers a new action
first then registers one or more menu items executing those actions.

<H2> API reference </H2>
<H3> event ACTE_action(int event_id, const char *name, int argc, int x, int y) </H3>
	Arguments:
	<OL>
		<LI> <a href="event_id.html">event_id</a>
		<LI> const char *name: name of the action (as registed using function action_register())
		<LI> int argc: number of arguments. Arguments can be accessed using function action_arg
		<LI> int x, int y: optional coords, if need_xy was not empty at action_register
	</OL>

<H3> function action_register(const char *name, const char *need_xy, const char *description, const char *syntax, const char *context) </H3>
	Arguments:
	<OL>
		<LI> const char *name: name of the action
		<LI> const char *need_xy: the question the user is asked when he needs to choose a coordinate; if empty, no coordinate is asked
		<LI> const char *description: description of the action (for the help)
		<LI> const char *syntax: syntax of the action (for the help)
		<LI> const char *context: this field is subject to remove - pass empty!
	</OL>
	Returns 0 on success.
	<p>
	Multiple actions can be registered. Any action registered by the script
	will trigger an ACTE_event sent to the script.

<H3> function const char *action_arg(int argn) </H3>
	Extracts action argument <I>argn</I> for the current action
	(makes sense only in an ACTE_action event handler).
	Arguments:
	<OL>
		<LI> int N: return the Nth argument
	</OL>
	Returns an argument or empty string if N is out of range [0..argc-1].
	<p>
	PCB action optionally have arguments. 
	The interface is "int argc, char *argv[]" based in PCB.
	Due to syntax limitations the event handler does not receive argv directly,.
	The script can access te argv[] array using action_arg().

<H3> event ACTE_gui_init(int event_id, int argc, char **argv); </H3>
	Called right after gui initialization, before the gui main loop.
	Arguments:
	<OL>
		<LI> <a href="event_id.html">event_id</a>
		<LI> int argc: number of arguments the gui was initialized with.
		<LI> char **argv[]: arguments the gui was initialized with - unaccessible for the scripts.
	</OL>

<H3> event ACTE_unload(int event_id, const char *conffile); </H3>
	Called right before unloading a script to give the script a chance
	to clean up.
	Arguments:
	<OL>
		<LI> <a href="event_id.html">event_id</a>
		<LI> const char *conffile: the name of the config file that originally triggered laoding the script, or empty if the script was loaded from the gui.
	</OL>

<H3> function int action(const char *cmdline) </H3>
	Execute a pcb-rnd action. Returns non-zero on error; generally
	returns value of the action (which is also non-zero on error).
	<OL>
		<LI> const char *cmdline: pcb-rnd command line in action_name(arg1, arg2, ..., argN) format
	</OL>

<H3> function void create_menu(const char *path, const char *action, const char *mnemonic, const char *hotkey, const char *tooltip) </H3>
	Create a new menu or submenu at path. Missing parents are created automatically
	with empty action, mnemonic, hotkey and tooltop.
	<OL>
		<LI> const char *path: the full path of the new menu
		<LI> const char *action: this action is executed when the user clicks on the menu
		<LI> const char *mnemonic: which letter to underline in the menu text (will be the fast-jump-there key once the menu is open)
		<LI> const char *hotkey: when this key is pressed in the main gui, the action is also triggered; the format is modifiers&lt;Key&gt;letter, where modifiers is Alt, Shift or Ctrl. This is the same syntax that is used in the .res files.
		<LI> const char *tooltip: short help text
	</OL>

</BODY>
</HTML>
