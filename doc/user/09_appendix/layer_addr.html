<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title> pcb-rnd user manual </title>
	<meta http-equiv="Content-Type" content="text/html;charset=us-ascii">
	<link rel="stylesheet" type="text/css" href="../../default.css">
</head>
<body>
<h2> Layer addressing </h2>
<p>
When an action or configuration file requires a <i>layer</i> or
<i>layer group</i> to be specified, it is usually done using the <i>layer
address</i> or <i>layer group address</i> sytax specified below.
<p>
However, some old actions still require the raw id or name of
a layer or layer group; in that case, the addressing syntax will not work
and the required data has to be specified as is, without any prefix.

<h3> Layer group address </h3>
<p>
The layer group address is used to name one or more matching layer group(s).
If the code needs only one layer group and the address matches multiple,
always the first match is used (the layer group with the lowest ID).
<p>
A layer group address contains at most two parts: the base address
and optional supplements. The full version is <i>base(supplements)</i>,
but supplements can be omitted so <i>base</i> alone is also valid.
<p>
The <i>base</i> part is one of the following syntaxes:
<p>
<table border=1>
<tr><th>syntax
    <th> description
    <th> example
<tr><td> @groupname
    <td> find groups by their user assigned name (case sensitive string match)
    <td> <i>@mysignal</i><br>matches groups whose name is "mysignal"

<tr><td> location-material
    <td> find groups by their location and material
    <td> <i>bottom-copper</i><br>matches groups that are on the bottom side and are of copper

<tr><td> type[-type...]
    <td> same as location-material: types can really be used in any amount and any order, but matching groups have to match all types specified
    <td> <i>mask</i><br>matches any group that is a solder mask

<tr><td> type:offs
    <td> offs is a positive integer; use the Nth group of that type from top
    <td> <i>copper:2</i><br>matches the second copper layer group from the top; offs is counted from 1, +1 meaning top surface layer

<tr><td> type:-offs
    <td> -offs is a negative integer; use the Nth group of that type from bottom
    <td> <i>copper:-3</i><br>matches the third copper layer group from the bottom; offs is counted from 1, -1 meaning bottom surface layer

<tr><td> #group_id
    <td> index by the ID of the group; useful for scripting
    <td> <i>#4</i><br>picks group 4, counting from 0

</table>
<p id="supplements">
When supplements are specified, it's a comma separated list of key=value pairs.
Available supplements are:
<ul>
	<li> purpose: specify matching layer group purpose field
	<li> bloat: bloat or shrink objects by the specified value (e.g. 1mm), when transformations are available
	<li> <a href="#partial">partial</a>: only export objects with the EXPORTSEL flag set, when doing an export
	<li> wireframe: draw layer with wireframe objects instead of solid objects
	<li> thin_draw: draw layer with thin centerline objects instead of solid objects (implies thin_draw_poly)
	<li> thin_draw_poly: draw layer with thin contour polygons instead of solid polygons
	<li> check_planes: draw only (clipped) polygons
	<li> flag_color: if the exporter supports colors, highlight objects that are found, selected or warned with screen color
	<li> hide_floaters: omit rendering subcircuit floaters; warning: floaters are not only silk refdes text
	<li> (TODO: supplement for inversion)
</ul>
<p>
Supplement examples:
<table border=1 cellspacing=0>
	<tr> <td> top-doc(purpose=assy)
	     <td> the explicit top assembly layer group (by type)
	<tr> <td> top-virtual(purpose=assy)
	     <td> the autogenerated top assembly layer group (by type); this works only if there is no explicit assy layer (legacy designs)
	<tr> <td> top-paste(bloat=0.1mm)
	     <td> when using the address in CAM, export the top paste group with all objects bloated up by 0.1mm
	<tr> <td> virtual(purpose=pdrill)
	     <td> for example in CAM: export plated drilled holes (padstack side effects, but no slots)
	<tr> <td> virtual(purpose=pdrill,bloat=0.1mm)
	     <td> the above two combined
</table>

<h3> Layer address </h3>
<p>
The layer address is used to name one or more matching layer(s).
If the code needs only one layer and the address matches multiple,
always the first match is used (the layer with the lowest ID).
Note: layers are not indexed in physical stack order.
<p>
There are two kind of layer addresses: direct and through-group.
<p>
The direct address has only two variants:
<table border=1>
<tr><th>syntax
    <th> description
    <th> example

<tr><td> #idx
    <td> layer index (the internal, unique numbering, from 0)
    <td> <i>#0</i><br>matches the first layer; useful only if the layer index was resolved earlier

<tr><td> @name
    <td> layer name - case sensitive match of user assigned layer name
    <td> <i>@mysignal</i><br>matches layers with name "mysignal"

<tr><td> &current
    <td> the currently selected layer
    <td> <i>&current</i>
</table>
<p>
The through grup address has a group address, a slash and a local
layer address. Counts are always from 1 (first layer within the 
group is count 1). It is one of:

<table border=1>
<tr><th>syntax
    <th> description
    <th> example

<tr><td> <i>group</i>/#count
    <td> layer index within the group
    <td> <i>top-copper/#2</i><br>matches the second layer in the top copper group

<tr><td> <i>group</i>/#-count
    <td> layer index within the group
    <td> <i>top-copper/#-1</i><br>matches the last layer in the top copper group

<tr><td> <i>group</i>/#count+
    <td> layer index within the group, considering only positive layers
    <td> <i>top-silk/#2</i><br>matches the second positive layer in the top silk group

<tr><td> <i>group</i>/#-count+
    <td> layer index within the group counted back from the last, considering only positive layers
    <td> <i>top-silk/#-1+</i><br>matches the last positive layer in the top silk group

<tr><td> <i>group</i>/#count-
    <td> layer index within the group, considering only negative (sub) layers
    <td> <i>top-silk/#2-</i><br>matches the second negative (sub) layer in the top silk group

<tr><td> <i>group</i>/#-count-
    <td> layer index within the group counted back from the last, considering only negative (sub) layers
    <td> <i>top-silk/#-1-</i><br>matches the last negative (sub) layer in the top silk group

<tr><td> <i>group</i>/@name
    <td> user assigned layer name matches <i>name</i> (only the group's layers are considered)
    <td> <i>top-copper/@gnd</i><br>matches the layer called "gnd" within the top copper group
</table>
<p>
Note: the full group addressing syntax can be used, so 
<pre>
top-doc(purpose=assy)/#-1
</pre>
<p>
works and means "fetch the first top documentation layer group whose purpose is
assy and pick the last layer in that group".

<h3> Best practices </h3>
<p>
Avoid addressing by user assigned name (the @ syntax): that scheme is
fragile and unique names are not guaranteed.
<p>
When addressing a layer for the first time, it is best to use the
group-type/#count syntax (e.g. top-copper/1 fir the first layer of the
top copper group).
<p>
If a lot of accesses to the same layer is required (and the layer stack
is not changed during the operation) the best strategy is to resolve the
layer once , using e.g. the group-type/#count, then remember its layer id
and use the faster #id addressing for subsequent access.

</body>
</html>
