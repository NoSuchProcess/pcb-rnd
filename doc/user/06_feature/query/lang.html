<html>
<body>

<H2 autotoc="yes"> Query: the query language </H2>

<h3 autotoc="yes"> Intro </h3>
<p>
A DRC program is an unordered list of rules. Rules are evaluated and
violations reported. The advantage of a declarative language is that
intermediate results can be cached and reused.
<p>
The language is intended to be human readable and human writable, but
the main goal is to let programs and scripts (e.g. netlisters) to
generate it.
<p>
A rule consists of three parts:
<ul>
	<li> the <i>rule</i> keyword; syntax: <b>rule NAME</b>, where NAME is an arbitrary string
	<li> build variables (lists) using search statements, using the <i>let</i> keyword
	<li> state assertions about those lists, using the <i>assert</i> keyword
	<li> comments, empty lines
</ul>
<p>
A simpler variant of a rule is a single expression, without any <i>rule</i> or
<i>let</i> or <i>assert</i> keywords in it.

<h3 autotoc="yes"> Variables (lists) </h3>
<p>
Variables are named by the user and are local to the rule. TODO
Lists are ordered.
A list is consists of zero or more objects. An object is:
<ul>
	<li> the board
	<li> a layer
	<li> a board drawing primitive (line, arc, polygon, via, text)
	<li> an element primitive (element line, element arc(?), pin, pad, element name)
	<li> an element as a whole
	<li> a net
	<li> a 2D coordinate with or without layer information
</ul>

<p>
Objects have named properties (or fields):
<ul>
	<li> core attributes: for each object type a predefined set of key=value
	     pairs that always exist (e.g. thickness of a line, start angle of
	     an arc); these field names starts with "p."
	<li> user attributes: free-form key=value pairs optionally assigned by
	     the user; these field names start with "a."
</ul>

<p>
Note: the language is case sensitive with keywords and builtins using
lowercase only. For better readability, in syntax description in this
document uppercase words are user chosen identifiers or fields. Whitespace
character sequences are usually treated as a single whitespace. (This
does not mean identifiers have to be uppercase in a program.)

<p>
The syntax of a search statement is:
<pre>
let LISTNAME EXPR
</pre>

<p>
It creates a list called LISTNAME and evaluates expression EXPR to all
available objects and adds the objects that match EXPR to the list. Each
matching object is added only once. The particular order of objects on
the list is random. Object "matches EXPR" when the EXPR evaluated on
the object yields true.

<p>
The current object used in the iteration during the search is called @.

<h3 autotoc="yes"> Expressions and values </h3>

<p>
An expression returns a value. A value can be:
<ul>
	<li>an object
	<li>a list
	<li>scalar: a number or string (might be suffixed, like "42 mm")
	<li>void (empty, also known as false)
</ul>

<p>
A value is considered true if:
<ul>
	<li>it is an existing object
	<li>it is a non-empty list
	<li>it is a non-zero number or non-empty string
	<li>it is a valid coordinate
</ul>

<p>
An expression is one of:

<table border=1 cellspacing=0>
<tr><th>syntax                      <th>meaning
<tr><td>(EXPR)                      <td>change precedence
<tr><td>EXPR || EXPR                <td>logical OR (result: number)
<tr><td>EXPR &amp;&amp; EXPR        <td>logical AND (result: number)
<tr><td>EXPR1 thus EXPR2            <td>evaluate to EXPR2 if EXPR1 is true, else to void
<tr><td>EXPR + EXPR                 <td>add (number only)
<tr><td>EXPR - EXPR                 <td>subtract (number only)
<tr><td>EXPR * EXPR                 <td>multiply or ... (number only)
<tr><td>EXPR / EXPR                 <td>multiply or ... (number only)
<tr><td>EXPR == EXPR                <td>the two values are equal
<tr><td>EXPR != EXPR                <td>the two values are not equal
<tr><td>EXPR ~ string               <td>regex match left EXPR using pattern right string
<tr><td>EXPR &gt; EXPR              <td>left EXPR is greater than right EXPR (number only)
<tr><td>EXPR &gt;= EXPR             <td>left EXPR is greater than or equal to right EXPR (number only)
<tr><td>EXPR &lt; EXPR              <td>left EXPR is less than right EXPR (number only)
<tr><td>EXPR &lt;= EXPR             <td>left EXPR is less than or equal to right EXPR (number only)
<tr><td>!EXPR                       <td>logical NOT (result: number, 0 or 1)
<tr><td>FUNC(EXPR, EXPR, ...)       <td>call a function with 0 or more arguments
<tr><td>EXPR.field                  <td>evaluated to the value of an object field (see P45, P46)
</table>

<p>
The syntax of an assertion is:
<pre>
assert EXPR
</pre>

<p>
If the EXPR in an assert evaluates to false, a DRC violation is generated.

<p>
If an assert EXPR is a list anywhere else than in a function argument, it is
evaluated for all valid members of the list (see P45, P46). For example
if there is a variable called FOO, which is a list of objects
(built using a search statement), expression
<pre>
FOO.p.thickness
</pre>
<p>
is evaluated as many times as many objects are on the list, and the
full assert is checked each case. If there is another similar list
called BAR, an expression:
<pre>
(FOO.p.thickness &lt; BAR.p.thickness)
</pre>
<p>
will compare each possible pair of FOO and BAR objects. That is, if
FOO has 4 objects and BAR has 15 objects, that is 4*15 = 60 comparisons.
<p>
However, each list is iterated only once, even if it is referenced multiple
times in the same expression. For example, with the above lists:
<pre>
(FOO.p.clearance &gt; 10 mil) &amp;&amp; (FOO.p.thickness &lt; BAR.p.thickness)
</pre>
the potential number of iterations is still 4*15, and not 4*4*15 (FOO is
not iterated twice). In practice the engine leverages lazy evaluation so
if FOO.p.clearance is smaller than 10 mil, the right size is not evaluated.
See also: P45, P46.
<p>
A field reference is valid if the field exists. For example a line object
has a thickness attribute, thus the .p.thickness is valid, but a polygon
object does not have a thickness and .p.thickness on a polygon is invalid.
An user attribute reference (e.g. field .a.baz) is valid if the attribute
key exists in the given object.
<p>
Invalid fields are skipped in iterations. Thus if variable BLOBB is a list
that consists of 3 line, 2 arc and a layer objects, the following assert
will result in 2 comparisons only:
<pre>
(BLOBB.p.width &gt;= 10 mm)
</pre>
(because only arc objects have valid .p.width field).

<p>
An invalid field in an expression is never considered an
error. In an assert statement it causes skipping an iteration. In a
search statement it evaluates to void.

<p>
A void value is never equal to anything. A void value is not equal
even to another void value.

<h3 autotoc="yes"> Misc </h3>
<p>
Comments are lines starting with #

</body>
</html>
