<html>
<body>

<h1> pcb-rnd internals </h1>

<h2> concepts </h2>

<p>
Convention: typedef'd types are called pcb_*_t - the corresponding struct
is pcb_*_s.

<h3> board </h3>
<p>
There is only one board being edited. A board is the model of the whole world
for pcb-rnd - any other, auxiliary data is only a partial description of a board.
The data struct for board is <i>pcb_board_t</i>. As of now, pcb-rnd edits only one
board at a time, and it is stored in a global variable called <i>PCB</i>.
The code is single threaded and is not reentrant.
<p>
Half of the board structure describes global board properties:
<ul>
	<li> layer stack
	<li> netlist
	<li> editor settings (e.g. routing styles, which layers are visible)
	<li> metadata (such as name of the author, size of the board).
</ul>
The other half is the actual board data, stored in a <i>pcb_data_t</i> field.
<p>
Relevant structs, variables and functions are in board.[ch].

<h3> data </h3>
<p>
A <i>pcb_data_t</i> contains everything to describe the 2d geometry of
an existing board:
<ul>
	<li> per-layer objects (e.g. lines, arcs, polygons)
	<li> global objects (e.g. elements, subcircuits, vias)
	<li> temporary logical connections (rat lines)
</ul>
<p>
Relevant structs, variables and functions are in data.[ch].
<p>
However, it does not contain the layer stackup, but references to it.
This means a data_t can be copied or moved from within one board to
another, even with mismatching layer stack. When a pcb_data_t is within a
pcb_board_t, the layer references are fixed, pointing to actual layers
within the board's layer stack (e.g. "layer 3 in the stack"). Such a layer is
also called a <i>real</i> layer. When a
pcb_data_t is used outside of a board (e.g. as a buffer), a generalized,
recipe-like layer description is used (e.g. "second copper layer counted
from the top"). Such a layer is not a <i>real</i> layer, but can be <i>bound</i>
to a real layer. The binding means that while it keeps it's recipe-like
description, it is also referring to an actual layer of the stack of the
current PCB structure. (This happens to subcircuits: they are specified
with generalized, recipe-like layers that are bound to the board's layer stack
once the subcircuit is placed on the board.)

<h3> buffers </h3>
<p>
Paste buffers are <i>pcb_buffer_t</i>; the main field is <i>pcb_data_t</i>.
<p>
Relevant structs, variables and functions are in buffer.[ch].
<p>
A paste buffer doesn't have a layer stack. When data is copied from a board
to a buffer, the layer references are generalized.

<h3> terminology: layers and layer groups</h3>
<p>
<i>Layers</i> are abstract canvases also serving as a logical grouping
of drawing primitives. Every <i>layer</i> is part of exactly one <i>layer
group</i>. A <i>layer group</i> is close to what a physical layer is on
the FR4.
<p>
Limitations:
<ul>
	<li> as of now pcb-rnd does not have Z-coordinate: layers have no thickness;
	<li> substrate is not represented at all in the layers stack.
</ul>
<p>
The location of a <i>layer group</i> on of:
<ul>
	<li> top (component) side
	<li> bottom (solder) side
	<li> inner (signal)
	<li> global (affects all locations, e.g. the outline layer for routing)
</ul>
<p>
In pcb-rnd only copper layers and the outline layer are fully explicit.
There are two hardwired silk layers, one for the top and one for the bottom side.
The silk layers are semi-explicit: they are existing layers in all structs
but:
<ul>
	<li> they are not part of the <i>layer group</i> system
	<li> unlike explicit layers they have fixed index (+1 and +2 beyond the last explicit layer)
	<li> created an moved by the core automatically
	<li> can not be removed
</ul>
<p>
The <i>outline layer</i> is a hack: it's really an internal copper layer. If
the code detects the name of the layer is "outline" anywhere, it branches.
<p>
There are a few virtual layers:
<ul>
	<li> [top|bottom] mask - no layer struct, calculated on-the-fly from pad data
	<li> [top|bottom] paste - no layer struct, calculated on-the-fly from pad data
	<li> Subcircuits - no layer struct, calculated on-the-fly from pad data
	<li> fab - no layer struct, calculated on-the-fly from drill/hole data
</ul>


<h3> pcb_data_t: global data </h3>
<p>
Global data affect all layers. The most trivial example is <i>via</i>:
it has a hole and the same copper ring on all layers. Another global
object pcb_data_t holds is an element. An element can have pads
on two copper layers and pins that affect all layers the same way as vias.
<p>
The third global object is subcircuit; using its own layer list, it potentially
can affect all layers of the board. The children objects of a subcircuit is
a pcb_data_t, which allows arbitrary (loop-free) recursion in data.

<h3> pcb_data_t: layer-local data </h3>
<p>
The data struct has a <i>pcb_layer_t</i> for each logical layer, to host
the per layer objects (drawing primitives).

<h3> the layer struct </h3>
<p>
Layer data is stored in struct <i>pcb_layer_t</i>. A layer has a list
for each object type (drawing primitive type): arcs, lines, polygons, etc.
<p>
Relevant structs, variables and functions are in layer.[ch].

<h2> map </h2>
<img src="data1.png">
