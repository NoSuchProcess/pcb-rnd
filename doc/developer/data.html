<html>
<body>

<h1> pcb-rnd internals </h1>

<h2> concepts </h2>

<p>
Convention: typedef'd types are called pcb_*_t - the corresponding struct
is pcb_*_s.

<h3> board </h3>
<p>
There is only one board being edited. A board is the model of the whole world
for pcb-rnd - any other, auxiliary data is only a partial description of a board.
The data struct for board is <i>pcb_board_t</i>. As of now, pcb-rnd edits only one
board at a time, and it is stored in a global variable called <i>PCB</i>.
The code is single threaded and is not reentrant.
<p>
Half of the board structure describes global board properties:
<ul>
	<li> layer stack
	<li> netlist
	<li> editor settings (e.g. routing styles, which layers are visible)
	<li> metadata (such as name of the author, size of the board).
</ul>
The other half is the actual board data, stored in a <i>pcb_data_t</i> field.
<p>
Relevant structs, variables and functions are in board.[ch].

<h3> data </h3>
<p>
A <i>pcb_data_t</i> contains everything to describe the 2d geometry of
an existing board:
<ul>
	<li> per-layer objects (e.g. lines, arcs, polygons)
	<li> global objects (e.g. elements, subcircuits, vias)
	<li> temporary logical connections (rat lines)
</ul>
<p>
Relevant structs, variables and functions are in data.[ch].
<p>
However, it does not contain the layer stackup, but references to it.
This means a data_t can be copied or moved from within one board to
another, even with mismatching layer stack. When a pcb_data_t is within a
pcb_board_t, the layer references are fixed, pointing to actual layers
within the board's layer stack (e.g. "layer 3 in the stack"). Such a layer is
also called a <i>real</i> layer. When a
pcb_data_t is used outside of a board (e.g. as a buffer), a generalized,
recipe-like layer description is used (e.g. "second copper layer counted
from the top"). Such a layer is not a <i>real</i> layer, but can be <i>bound</i>
to a real layer. The binding means that while it keeps it's recipe-like
description, it is also referring to an actual layer of the stack of the
current PCB structure. (This happens to subcircuits: they are specified
with generalized, recipe-like layers that are bound to the board's layer stack
once the subcircuit is placed on the board.)

<h3> buffers </h3>
<p>
Paste buffers are <i>pcb_buffer_t</i>; the main field is <i>pcb_data_t</i>.
<p>
Relevant structs, variables and functions are in buffer.[ch].
<p>
A paste buffer doesn't have a layer stack. When data is copied from a board
to a buffer, the layer references are generalized.

<h3> terminology: layers and layer groups</h3>
<p>
<i>Layers</i> are abstract canvases also serving as a logical grouping
of drawing primitives. Every <i>layer</i> is part of exactly one <i>layer
group</i>. A <i>layer group</i> is close to what a physical layer is on
the FR4.
<p>
Limitations:
<ul>
	<li> as of now pcb-rnd does not have Z-coordinate: layers have no thickness;
	<li> substrate is not represented at all in the layers stack.
</ul>
<p>
The location of a <i>layer group</i> on of (flags are in layer.h):
<ul>
	<li> top (component) side - PCB_LYT_TOP
	<li> bottom (solder) side - PCB_LYT_BOTTOM
	<li> inner or internal (e.g. signal) - PCB_LYT_INTERN
	<li> global (affects all locations, e.g. the outline layer for routing) - 0
</ul>
<p>
In pcb-rnd most layer types are fully explicit:
<ul>
	<li> copper - PCB_LYT_COPPER (not composite)
	<li> silk screen - PCB_LYT_SILK
	<li> mask - PCB_LYT_MASK
	<li> paste - PCB_LYT_PASTE
	<li> outline - PCB_LYT_OUTLINE (not composite)
</ul>
<p>
The layers of a composite layer group are combined + and -, depending
on the PCB_LYC_SUB in their comb field.
<p>
Assumptions: there are two silk layers, one for the top and one for the bottom
side and there are always a top and a bottom copper layer. (Long term
assumptions will be removed.) The outline layer has to be global.
<p>
The rest of the layers are virtual layers, often just GUI hacks, e.g.:
<ul>
	<li> Subcircuits - no layer struct, calculated on-the-fly from pad data
	<li> fab - no layer struct, calculated on-the-fly from drill/hole data
</ul>

<h3> pcb_data_t: global data </h3>
<p>
Global data affect all layers. The most trivial example is <i>via</i>:
it has a hole and the same copper ring on all layers. Another global
object pcb_data_t holds is an element. An element can have pads
on two copper layers and pins that affect all layers the same way as vias.
<p>
The third global object is subcircuit; using its own layer list, it potentially
can affect all layers of the board. The children objects of a subcircuit is
a pcb_data_t, which allows arbitrary (loop-free) recursion in data.

<h3> pcb_data_t: layer-local data </h3>
<p>
The data struct has a <i>pcb_layer_t</i> for each logical layer, to host
the per layer objects (drawing primitives).

<h3> the layer struct </h3>
<p>
Layer data is stored in struct <i>pcb_layer_t</i>. A layer has a list
for each object type (drawing primitive type): arcs, lines, polygons, etc.
<p>
Relevant structs, variables and functions are in layer.[ch].

<h2> map </h2>
<img src="data1.png">
