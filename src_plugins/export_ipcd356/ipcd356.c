/*
 *                            COPYRIGHT
 *
 *  pcb-rnd, interactive printed circuit board design
 *
 *  ipc-d-356 export plugin
 *  pcb-rnd Copyright (C) 2018 Tibor 'Igor2' Palinkas
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 *  Contact:
 *    Project page: http://repo.hu/projects/pcb-rnd
 *    lead developer: email to pcb-rnd (at) igor2.repo.hu
 *    mailing list: pcb-rnd (at) list.repo.hu (send "subscribe")
 */

#include "config.h"

#include <stdio.h>

#include "board.h"
#include "data.h"
#include "safe_fs.h"
#include "conf_core.h"
#include "compat_misc.h"

#include "hid.h"
#include "hid_nogui.h"
#include "hid_helper.h"
#include "hid_attrib.h"
#include "hid_init.h"
#include "plugins.h"

static const char *ipcd356_cookie = "ipcd356 exporter";

/*** low level export code ***/
typedef struct {
	pcb_board_t *pcb;
	FILE *f;
	int is_mil;
} write_ctx_t;

static void ipcd356_write_head(write_ctx_t *ctx)
{
	char utc[64];

	pcb_print_utc(utc, sizeof(utc), 0);

	fprintf(ctx->f, "C  IPC-D-356 Netlist generated by pcb-rnd " PCB_VERSION "\n");
	fprintf(ctx->f, "C  \n");
	fprintf(ctx->f, "C  File created on %s\n", utc);
	fprintf(ctx->f, "C  \n");
	fprintf(ctx->f, "P  JOB   %s\n", (PCB->Name == NULL) ? PCB->Filename : PCB->Name);
	fprintf(ctx->f, "P  CODE  00\n");
	fprintf(ctx->f, "P  UNITS CUST %d\n", ctx->is_mil ? 0 : 1);
	fprintf(ctx->f, "P  DIM   N\n");
	fprintf(ctx->f, "P  VER   IPC-D-356\n");
	fprintf(ctx->f, "P  IMAGE PRIMARY\n");
	fprintf(ctx->f, "C  \n");
}

static void ipcd356_write_foot(write_ctx_t *ctx)
{
	fprintf(ctx->f, "999\n\n");
}

static void ipcd356_write(pcb_board_t *pcb, FILE *f)
{
	write_ctx_t ctx;

	ctx.pcb = pcb;
	ctx.f = f;
	ctx.is_mil = (strcmp(conf_core.editor.grid_unit->suffix, "mil") == 0);

	ipcd356_write_head(&ctx);

	ipcd356_write_foot(&ctx);
}

/*** export hid administration and API/glu ***/

static pcb_hid_attribute_t ipcd356_options[] = {
/* %start-doc options "8 IPC-D-356 Netlist Export"
@ftable @code
@item --netlist-file <string>
Name of the IPC-D-356 Netlist output file.
@end ftable
%end-doc
*/
	{
	 "netlistfile",
	 "Name of the IPC-D-356 Netlist output file",
	 PCB_HATT_STRING,
	 0, 0, {0, 0, 0}, 0, 0},
#define HA_ipcd356_filename 0
};

#define NUM_OPTIONS (sizeof(ipcd356_options)/sizeof(ipcd356_options[0]))

static pcb_hid_attr_val_t ipcd356_values[NUM_OPTIONS];

static pcb_hid_attribute_t *ipcd356_get_export_options(int *n)
{
	static char *last_fn = NULL;

	if (PCB != NULL)
		pcb_derive_default_filename(PCB->Filename, &ipcd356_options[HA_ipcd356_filename], ".net", &last_fn);

	if (n != NULL)
		*n = NUM_OPTIONS;

	return ipcd356_options;
}

static int ipcd356_parse_arguments(int *argc, char ***argv)
{
	return pcb_hid_parse_command_line(argc, argv);
}

static void ipcd356_do_export(pcb_hid_attr_val_t *options)
{
	int n;
	const char *fn;
	FILE *f;

	if (!options) {
		ipcd356_get_export_options(0);

		for (n = 0; n < NUM_OPTIONS; n++)
			ipcd356_values[n] = ipcd356_options[n].default_val;

		options = ipcd356_values;
	}

	fn = options[HA_ipcd356_filename].str_value;
	if (fn == NULL)
		fn = "pcb-rnd-out.net";

	f = pcb_fopen(fn, "w");
	if (f == NULL) {
		pcb_message(PCB_MSG_ERROR, "Can't open %s for write\n", fn);
		return;
	}
	ipcd356_write(PCB, f);
	fclose(f);
}

static pcb_hid_t ipcd356_hid;

int pplg_check_ver_export_ipcd356(int ver_needed) { return 0; }

void pplg_uninit_export_ipcd356(void)
{
	pcb_hid_remove_attributes_by_cookie(ipcd356_cookie);
}

int pplg_init_export_ipcd356(void)
{
	PCB_API_CHK_VER;
	memset(&ipcd356_hid, 0, sizeof(pcb_hid_t));

	pcb_hid_nogui_init(&ipcd356_hid);

	ipcd356_hid.struct_size = sizeof(pcb_hid_t);
	ipcd356_hid.name = "IPC-D-356";
	ipcd356_hid.description = "Exports to IPC-D-356 netlist";
	ipcd356_hid.exporter = 1;

	ipcd356_hid.get_export_options = ipcd356_get_export_options;
	ipcd356_hid.do_export = ipcd356_do_export;
	ipcd356_hid.parse_arguments = ipcd356_parse_arguments;

	pcb_hid_register_hid(&ipcd356_hid);

	pcb_hid_register_attributes(ipcd356_options, sizeof(ipcd356_options) / sizeof(ipcd356_options[0]), ipcd356_cookie, 0);
	return 0;
}
