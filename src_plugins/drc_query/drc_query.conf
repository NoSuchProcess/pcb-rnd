li:pcb-rnd-conf-v1 {
	ha:overwrite {
		ha:plugins {
			ha:drc_query {
				disable=0

				li:definitions {
					ha:min_drill {
						type = coord
						legacy = design/min_drill
						desc = {minimum drill diameter}
					}
					ha:hole_overlap_factor {
						type = real
						default = 0.0
						desc = {How much drilled holes may overlap [-1..+1]; 0 means touching holes are reported; positive numbers allow more overlap, negative numbers report non-overlapping but close holes}
					}
				}

				li:rules {

					ha:hole_dia {
						type = single hole
						title = hole too small
						desc = padstack hole diameter is too small
						query = {(@.hole > 0) && (@.hole < $min_drill)}
					}

					ha:hole_overlap {
						type = pair hole
						title = overlapping holes
						desc = padstack holes overlap
						disable = 0
						query = {
rule overlap
let A @.type==PSTK
let B A
assert (A.ID > B.ID) && (distance(A.x, A.y, B.x, B.y) < (A.hole + B.hole)/(2*(1+$hole_overlap_factor))) thus violation(DRCGRP1, A, DRCGRP2, B, DRCMEASURE, distance(A.x, A.y, B.x, B.y), DRCEXPECT, (A.hole + B.hole)/(2*(1+$hole_overlap_factor)))
						}
					}

					ha:net_break {
						type = broken net
						title = insufficient overlap
						desc = the overlap between two objects in the net is insufficient and can lead to broken network during board fabrication
						disable = 0
						query = {
rule net brk
let N netlist()
let O netsegs(N)
assert netbreak(O, $min_copper_overlap)
						}
					}

					ha:net_short {
						type = shorted nets
						title = net too close to other net
						desc = insufficient clearance between an object of the network and objects of other networks
						disable = 0
						query = {
rule net short
let N netlist()
let O netsegs(N)
assert netshort(O, $min_copper_clearance)
						}
					}

				}
			}
		}
	}
}
